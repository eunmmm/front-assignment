# Todo List

## 기본 설정

### 프로젝트 클론 및 설치

먼저, 아래의 명령어를 사용하여 프로젝트를 클론합니다.

```bash
git clone https://github.com/eunmmm/front-assignment.git
cd front-assignment
```

그런 다음, 프로젝트 디렉토리로 이동한 후 필요한 패키지를 설치합니다.

```bash
npm install
```

### 프로젝트 실행

아래 명령어를 통해 로컬 개발 서버를 실행할 수 있습니다.

```bash
npm run dev
```

이제 브라우저에서 http://localhost:3000을 열어 프로젝트를 확인할 수 있습니다.

### Node.js 버전

Node.js 20.17.0 버전(최신 LTS 버전)을 사용하고 있습니다. 선택한 이유는 다음과 같습니다.

LTS (장기 지원): LTS 버전은 오랜 기간 안정적으로 보안 패치와 버그 수정을 제공하므로, 회사 프로젝트처럼 장기적으로 운영될 서비스에 적합합니다.
최신 기술과 성능: 최신 릴리스로, 새로운 기능과 최적화된 성능을 활용할 수 있습니다. 새로 시작하는 프로젝트인 만큼, 가능한 최신 기술을 도입하여 유지보수와 확장성을 고려하였습니다.

이러한 이유로, 새로 시작하는 프로젝트에 최신 LTS 버전을 선택했습니다.

## 프로젝트 구조

```plaintext
src/
├── app/
│   ├── todo-list/
│   │   ├── [id]/
│   │   │   ├── actions.ts
│   │   │   ├── page.tsx
│   │   │   └── error.tsx
│   │   ├── page.tsx
│   │   └── layout.tsx
│   ├── layout.tsx
│   └── globals.css
├── components/
│   ├── todo/
│   │   ├── AlertDialog/
│   │   ├── TodoDetail/
│   │   ├── TodoEditForm/
│   │   ├── TodoForm/
│   │   ├── TodoFormDialog/
│   │   ├── TodoItem/
│   │   └── TodoListContent/
│   └── ui/
│       ├── Button/
│       ├── Checkbox/
│       ├── Dialog/
│       └── Loading/
├── constants/
│   └── api.ts
├── contexts/
│   └── ThemeContext.tsx
├── lib/
│   └── api.ts
├── styles/
│   ├── globals.scss
│   └── variables.scss
└── types/
    └── todo.ts

```

프로젝트 구조를 더 깔끔하고 명확하게 만든다고 생각하여 src 안에 모든 소스 코드를 넣었습니다.

또한, 컴포넌트를 구성할 때는 Atomic Design의 일부 원칙을 반영했습니다. Atomic Design은 UI 컴포넌트를 원자(Atoms), 분자(Molecules), 유기체(Organisms) 등으로 구분하는 방법론입니다. 이 구조를 참고하여 ui 폴더에 재사용 가능한 작은 컴포넌트들(버튼, 체크박스 등)을 모았고, 그 외의 특정 기능을 가진 컴포넌트들은 components 폴더에 넣어 관리하도록 했습니다.

## 구현 기능

- 할 일 추가, 수정, 삭제
- 할 일 완료 상태 업데이트
- 로딩 및 에러 처리
- 다크 모드 지원
  - 사용자의 편의를 고려하여 다크 모드를 지원하는 기능을 추가했습니다. 이는 ThemeContext를 통해 구현하였습니다.
- 입력 검증 (Validation) 기능
  - zod 라이브러리를 사용하여 사용자가 입력한 제목과 설명에 대한 유효성을 검사합니다.

지원 공고에 명시된 3가지 미션을 반영하여 아래와 같은 추가 기능을 구현하려고 하였습니다.

1. 프로그램 전문성: zod 라이브러리를 통해 데이터 유효성을 철저히 검증하여 오류를 줄이려 했씁니다.

2. 사용자 편의성: 다크 모드와 같은 사용자 친화적인 기능을 추가하고, 모바일에서도 사용하기 적합한 반응형 디자인을 적용했습니다. 이를 통해 모든 디바이스에서 일관된 사용자 경험을 제공하였습니다.

3. 성능 최적화: API 호출과 관련된 로딩 상태와 에러 처리를 최적화하려 했습니다.

## 고려했던 사항

- 에러 핸들링

비동기 API 호출에서 발생하는 다양한 에러(예: 네트워크 오류, 서버 오류 등)를 사용자에게 명확히 전달하는 부분이 어려웠던 것 같습니다.
기존에는 중복된 에러 핸들링 코드가 많았는데, 이를 통합하고 중복을 줄이기 위해 fetchWithErrorHandling 함수를 따로 작성하여 각 API 호출에서 일관되게 사용하도록 했습니다.

- Next.js의 Server Side Fetching 및 Server Actions 활용

Next.js를 처음 사용하면서 Server Side Fetching (서버 사이드 데이터 패칭) 및 Server Actions (서버 액션)을 어떻게 적절히 활용할지에 대해 많은 고민을 했습니다.
특히, 클라이언트와 서버 간의 데이터 흐름을 명확히 이해하고, 어느 부분에서 서버에서 데이터를 가져오고 클라이언트에서 다뤄야 할지 판단하는 것이 어려웠습니다.
예를 들어, getTodo 함수를 통해 서버에서 데이터를 가져올 때, useEffect와 서버 측 데이터 패칭의 역할을 어떻게 분리할 것인가에 대해 많은 고민이 있었습니다. 최종적으로, Server Actions를 사용하여 중요한 비즈니스 로직은 서버에서 처리하도록 하고, 클라이언트 측에서는 이를 UI에 맞게 반영하도록 구조를 잡았습니다.

- 테스트 코드 작성과 코드 커버리지

테스트 코드를 작성하는 과정에서, 각 컴포넌트와 함수가 예상대로 동작하는지를 확인하는 것이 매우 중요하다는 것을 깨달았습니다. 특히 CRUD 기능을 구현하면서, 단순한 기능일지라도 예기치 않은 오류나 사이드 이펙트가 발생할 수 있다는 점을 직접 경험했습니다. 예를 들어, 삭제 기능에서 페이지 리다이렉션이 제대로 이루어지지 않거나, 업데이트 기능에서 데이터가 예상치 않게 반영되지 않는 경우를 테스트 코드로 발견할 수 있었습니다.

코드 커버리지를 70% 이상으로 유지하기 위해 프로젝트의 모든 주요 기능에 대해 테스트를 작성했고, 이를 통해 코드의 안정성을 크게 높일 수 있었던 것 같습니다.

## 회고

이번 과제를 진행하면서 폴더 구조부터 시작해 하나하나 깊이 고민해보는 좋은 기회가 되었습니다. 처음에는 컴포넌트를 많이 쪼개고, 최대한 재사용 가능한 구조로 설계하려고 했습니다. 하지만 프로젝트가 진행되면서 컴포넌트 간의 의존성이 복잡해지고, 리팩토링 과정에서 예상치 못한 에러들이 발생하면서 통일성 있게 코드를 작성하는 데 어려움을 느꼈습니다.

특히, Next.js를 처음 사용하면서 Server Side Fetching 및 Server Actions와 같은 새로운 개념들을 이해하고 적용하는 데 시간이 조금 걸렸는데요. 에러 핸들링에서도 여러 번 시행착오를 겪으며 어떻게 하면 사용자 경험을 해치지 않으면서도 안정적인 애플리케이션을 유지할 수 있을지 고민했습니다. 다크모드나 데이터 유효성 검사를 위한 Zod 라이브러리를 사용하는 것도 처음이었지만, 이를 통해 사용자의 편의성과 정확성을 향상시킬 수 있는 기능들을 구현할 수 있었습니다.

아쉬운 점이 많았던 프로젝트였지만, 그만큼 배운 것도 많았습니다. 테스트 코드 작성의 중요성을 체감했고, 더 나은 코드 구조와 유지보수성을 고민하게 되었습니다. 이러한 경험을 통해 앞으로 더욱 나은 개발자로 성장할 수 있는 발판을 마련할 수 있었던 것 같습니다.

마지막으로, 이번 프로젝트를 통해 좋은 기회를 주셔서 감사합니다. 앞으로도 계속해서 배움을 이어가고 발전해 나가겠습니다.
